(defun isPrime (n &optional (d 2))
  (or (= n 1)
     ( or (= d n)
      (and (/= (rem n d) 0)
	   (isPrime n (+ d 1))))))

(defun flatten (l)
  (cond ((null l) nil)
        ((atom (car l)) (cons (car l) (flatten (cdr l))))
        (t (append (flatten (car l)) (flatten (cdr l))))))
(defun rev-helper (list reversed)
    (if (endp list)
      reversed
      (rev-helper (rest list)
                  (list* (first list)
                         reversed))))
(defun OccurencesOfPrimes (l)
  (assert (listp l) (l)
"L must be a list, instead it is ~S." l)
  (setq y 0)
  (setq l (flatten l))
  (dolist (x l y) (if (isPrime x) (setq y (+ y 1))))
  )

(defun GetListOfPrimes (l)
  (assert (listp l) (l)
	  "L must be a list, instead it is ~S." l)
  (setq y '())
  (setq l (flatten l))
  (dolist (x l y) (if (isPrime x) (setq y (cons x y))))
  (setq y (rev-helper y '())
  ))
(defun SumIf (l1 l2)
  (setq l1 (flatten l1))
  (setq l2 (flatten l2))
  (setq y2 0)(setq y1 0)
  (dolist (x1 l1 y1) (dolist (x2 l2 y2) (if (= x1 x2) (setq y1 (+ x2 y1))))))
